{
    "contents" : "#EM algorithm for mixture of two normal distributions \n\nmixture <- function(y,method, maxit = NULL, tol = 1e-8,param0=NULL)\n  \n{ y=as.matrix(y)\n  n=length(y)\n  \n  method=match.arg(method,c(\"EM\",\"Newton\"))\n  #####################################################################\n  if (method==\"EM\"){\n    ###\n    if ( is.null(maxit)){\n      if (method==\"Newton\")\n        (maxit=100)\n      if (method==\"EM\")\n        (maxit=500)\n    }\n    if (is.null(param0))\n    {th1=c(0.1, 1, 4, 4, 4)}      # theta=(pi1, mu1, mu2, sigma^2, sigma^2), starting value\n    else \n    {th1=param0 }\n    \n    ######\n    \n    t=vector(length=5)     #t={t[1],t[2],t[3],t[4],t[5])}. where \n    #t[1]=pi1, t[2]=mu1, t[3]=mu2, t[4]=sigma^2, t[5]=sigma^2\n    \n    y1=function(t) { (t[1]*exp(-((y-t[2])^2)/(2*t[4])))/((2*pi*t[4])^0.5)}   #have 1000 X's\n    y2=function(t) { ((1-t[1])*exp(-((y-t[3])^2)/(2*t[5])))/((2*pi*t[5])^0.5)}\n    \n    z1m=y1(th1)/(y1(th1)+y2(th1))     # z1m=Zij(m)\n    z2m=y2(th1)/(y1(th1)+y2(th1))\n    \n    #sum(z1m)+sum(z2m)    #should add up to n=1000\n    \n    th2=vector(length=5)\n    \n    th2[1]=sum(z1m)/(sum(z1m)+sum(z2m))\n    th2[2]=(t(z1m)%*%y)/sum(z1m)\n    th2[3]=(t(z2m)%*%y)/sum(z2m)\n    th2[4]=(t(z1m)%*%((y-th2[2])^2))/sum(z1m)\n    th2[5]=(t(z2m)%*%((y-th2[3])^2))/sum(z2m)\n    \n    th2\n    \n    count=1\n    \n    while (max(abs(th2-th1))>tol) {\n{th1=th2\n z1m=y1(th1)/(y1(th1)+y2(th1))   \n z2m=y2(th1)/(y1(th1)+y2(th1))\n \n th2=vector(length=5)\n \n th2[1]=sum(z1m)/(sum(z1m)+sum(z2m))\n th2[2]=(t(z1m)%*%y)/sum(z1m)\n th2[3]=(t(z2m)%*%y)/sum(z2m)\n th2[4]=(t(z1m)%*%((y-th2[2])^2))/sum(z1m)\n th2[5]=(t(z2m)%*%((y-th2[3])^2))/sum(z2m)\n if (count>maxit)\n   break\n}\ncount=count+1\n    }\n    \n    \n    \n    \n    l <- expression(log(llambda * exp(-(y - lmu1) ^ 2 / (2 * lsigma1)) / sqrt(2 * pi * lsigma1) + \n                          (1 - llambda) * exp(-(y - lmu2) ^ 2 / (2 * lsigma2)) / sqrt(2 * pi * lsigma2)))\n    der <- deriv3(l, c('llambda', 'lmu1', 'lmu2', 'lsigma1', 'lsigma2'))\n    \n    ## mle is the MLE\n    llambda <- th2[1]\n    lmu1 <- th2[2]\n    lmu2 <- th2[3]\n    lsigma1 <- th2[4]\n    lsigma2 <- th2[5]\n    \n    grad <- attr(eval(der),\"gradient\")\n    \n    score <- matrix(0,5,5)\n    for (i in 1:n)\n    {\n      score <- score + grad[i, ] %*% t(grad[i, ])\n    }\n    score <- score\n    sd <- c(sqrt(diag(solve(score))))\n    \n    \n    \n    \n    \n    x=list(th2[1],th2[2],th2[3],th2[4],th2[5])\n    names(x) <- c(\"lambda\",\"mu1\",\"mu2\",\"sigma1\",\"sigma2\")\n    print(x)\n    \n    #list of sd\n    y=list(sd[1],sd[2],sd[3],sd[4],sd[5])\n    names(y) <- c(\"lambda\",\"mu1\",\"mu2\",\"sigma1\",\"sigma2\")\n    print(y)\n    \n    print(count)\n  }                \n  \n  #END OF EM\n  \n  \n  ############################################################### \n  \n  if (method==\"Newton\"){\n    # run EM\n    \n    ###\n    if ( is.null(maxit)){\n      if (method==\"Newton\")\n        (maxit=100)\n      if (method==\"EM\")\n        (maxit=500)\n    }\n    if (is.null(param0))\n    {th1=c(0.1, 1, 40, 40, 40)}      # theta=(pi1, mu1, mu2, sigma^2, sigma^2), starting value\n    else \n    {th1=param0 }\n    \n    ####\n    \n    t=vector(length=5)     #t={t[1],t[2],t[3],t[4],t[5])}. where \n    #t[1]=pi1, t[2]=mu1, t[3]=mu2, t[4]=sigma^2, t[5]=sigma^2\n    \n    y1=function(t) { (t[1]*exp(-((y-t[2])^2)/(2*t[4])))/((2*pi*t[4])^0.5)}   #have 1000 X's\n    y2=function(t) { ((1-t[1])*exp(-((y-t[3])^2)/(2*t[5])))/((2*pi*t[5])^0.5)}\n    \n    z1m=y1(th1)/(y1(th1)+y2(th1))     # z1m=Zij(m)\n    z2m=y2(th1)/(y1(th1)+y2(th1))\n    \n    #sum(z1m)+sum(z2m)    #should add up to n=1000\n    \n    th2=vector(length=5)\n    \n    th2[1]=sum(z1m)/(sum(z1m)+sum(z2m))\n    th2[2]=(t(z1m)%*%y)/sum(z1m)\n    th2[3]=(t(z2m)%*%y)/sum(z2m)\n    th2[4]=(t(z1m)%*%((y-th2[2])^2))/sum(z1m)\n    th2[5]=(t(z2m)%*%((y-th2[3])^2))/sum(z2m)\n    \n    th2\n    \n    count=1\n    \n    while (max(abs(th2-th1))>tol) {\n{th1=th2\n z1m=y1(th1)/(y1(th1)+y2(th1))   \n z2m=y2(th1)/(y1(th1)+y2(th1))\n \n th2=vector(length=5)\n th2[1]=sum(z1m)/(sum(z1m)+sum(z2m))\n th2[2]=(t(z1m)%*%y)/sum(z1m)\n th2[3]=(t(z2m)%*%y)/sum(z2m)\n th2[4]=(t(z1m)%*%((y-th2[2])^2))/sum(z1m)\n th2[5]=(t(z2m)%*%((y-th2[3])^2))/sum(z2m)\n if (count>maxit)\n   break\n}\ncount=count+1\n    }\n    \n    #END OF WITHIN EM\n    ####################################\n    #print(th2)\n    \n    \n    th1[1]=th2[1]\n    th1[2]=th2[2]\n    th1[3]=th2[3]\n    th1[4]=sqrt(th2[4])\n    th1[5]=sqrt(th2[5])\n    \n    th1=th1+0.01\n    \n    lmix2 <- deriv3(\n      ~ -log(p*dnorm((y-u1)/s1)/s1 + (1-p)*dnorm((y-u2)/s2)/s2),\n      c(\"p\",\"u1\",\"u2\",\"s1\",\"s2\"),\n      function(y,p,u1,u2,s1,s2) NULL)\n    \n    mix.gr <- function(theta,y){\n      p <- theta[1];u1 <- theta[2]; u2 <- theta[3]; s1 <- theta[4]; s2 <- theta[5]\n      colSums(attr(lmix2(y,p,u1,u2,s1,s2),\"gradient\"))}\n    \n    mix.he <- function(theta,y){\n      p <- theta[1];u1 <- theta[2]; u2 <- theta[3]; s1 <- theta[4]; s2 <- theta[5]\n      colSums(attr(lmix2(y,p,u1,u2,s1,s2),\"hessian\"))}\n    \n    \n    th2=th1-solve(mix.he(th1,y))%*%mix.gr(th1,y)\n    \n    count=1\n    \n    while (max(abs(th2-th1))>tol) {\n{th1=th2\n th2=th1-solve(mix.he(th1,y))%*%mix.gr(th1,y)\n \n if (count>maxit)\n   break\n}\ncount=count+1\n    }\n    \n    l <- expression(log(llambda * exp(-(y - lmu1) ^ 2 / (2 * lsigma1)) / sqrt(2 * pi * lsigma1) + \n                          (1 - llambda) * exp(-(y - lmu2) ^ 2 / (2 * lsigma2)) / sqrt(2 * pi * lsigma2)))\n    der <- deriv3(l, c('llambda', 'lmu1', 'lmu2', 'lsigma1', 'lsigma2'))\n    \n    ## mle is the MLE\n    llambda <- th2[1]\n    lmu1 <- th2[2]\n    lmu2 <- th2[3]\n    lsigma1 <- th2[4]* th2[4]\n    lsigma2 <- th2[5]*th2[5]\n    \n    grad <- attr(eval(der),\"gradient\")\n    \n    score <- matrix(0,5,5)\n    for (i in 1:n)\n    {\n      score <- score + grad[i, ] %*% t(grad[i, ])\n    }\n    score <- score\n    sd <- c(sqrt(diag(solve(score))))\n    \n    \n    \n    x=list(th2[1],th2[2],th2[3],th2[4]*th2[4],th2[5]*th2[5])\n    names(x) <- c(\"lambda\",\"mu1\",\"mu2\",\"sigma1\",\"sigma2\")\n    print(x)\n    \n    #list of sd\n    y=list(sd[1],sd[2],sd[3],sd[4],sd[5])\n    names(y) <- c(\"lambda\",\"mu1\",\"mu2\",\"sigma1\",\"sigma2\")\n    print(y)\n    \n    \n    \n    \n    \n    \n    \n    count \n  }  \n  ########################################################\n  \n  # END OF Newton\n  \n}\n\n",
    "created" : 1386200368718.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2675930021",
    "id" : "D8EA1942",
    "lastKnownWriteTime" : 1386201860,
    "path" : "~/Desktop/AdvStatComp/Homework2/R/Homework2.R",
    "project_path" : "R/Homework2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}